# Фінальний проект з алгоритмів та структур даних

Привіт! Я підготувала повний розв'язок усіх семи завдань фінального проєкту.
Кожен файл містить окреме рішення та приклад запуску.

## Вміст репозиторію

|     Файл     |                                                  Опис                                                      |
|--------------|------------------------------------------------------------------------------------------------------------|
| **task1.py** | Однозв'язний список: реверс, сортування вставками, злиття двох відсортованих списків.                      |
| **task2.py** | Рекурсивне малювання фракталу «дерево Піфагора» з можливістю задати рівень рекурсії.                       |
| **task3.py** | Алгоритм Дейкстри з використанням `heapq` для пошуку найкоротших шляхів у зваженому графі.                 |
| **task4.py** | Візуалізація бінарної купи у вигляді дерева з бібліотекою `networkx`.                                      |
| **task5.py** | Графічний показ DFS та BFS обходів бінарного дерева без рекурсії.                                          |
| **task6.py** | Порівняння жадібного алгоритму і алгоритму динамічного програмування для вибору їжі при обмеженому бюджеті.|
| **task7.py** | Моделювання кидків двох кубиків методом Монте‑Карло та порівняння з аналітикою.                            |

## Мої висновки

### Завдання 1
Я переконалась, що маніпулювати вказівниками в однозв'язному списку легше, ніж здається. Реверс — це всього лише перестановка посилань. Сортування вставками показало, що іноді простий алгоритм цілком достатній, коли структура даних «дешева» для вставки.

### Завдання 2
Фрактал «дерево Піфагора» чудово демонструє силу рекурсії. Я відчула, що рекурсія — це природний спосіб мислити, коли маєш справу з фігурами, які самовідтворюються.

### Завдання 3
Реалізуючи Дейкстру через `heapq`, я усвідомила, наскільки пріоритетна черга пришвидшує алгоритм. Без неї пошук мінімальної відстані перетворився б на лінійний скан на кожній ітерації.

### Завдання 4 та 5
Візуалізація структур даних — це не лише «красиво», а й корисно: миттєво видно, де помилка. Я навчилася генерувати координати вузлів у дусі рекурсивного розмітчика й використав це двічі: спершу для купи, потім — для обходів.

### Завдання 6
Жадібний підхід дав швидку, але не оптимальну відповідь, тоді як динамічне програмування знайшло справді найкращий набір. Я побачила класичну різницю між «швидко й майже добре» та «повільніше, але ідеально».

### Завдання 7
Монте‑Карло підтвердив аналітичні ймовірності з похибкою, що спадає при збільшенні кількості ітерацій. Я ще раз переконалася: статистичні методи стають потужнішими, коли зростає обсяг даних.
